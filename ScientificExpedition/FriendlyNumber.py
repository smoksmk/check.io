#!/usr/bin/python3
# -*- coding: utf-8 -*-

def toFixed(f, n = 0):
    if not n:
        return int(f)
    else:
        return '{0:.{1}f}'.format(f, n)

def division(number, base, maxcount, i=0):
    if abs(number) >= base and maxcount-1 > i:
        number = float(number) / base
        number, i = division(number, base, maxcount, i=i+1)
    return [number, i]

def friendly_number(number, base=1000, decimals=0, suffix='', powers=['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']):
    res = division(number, base, len(powers))
    result = "{0}{1}{2}".format(toFixed(res[0], decimals), powers[res[1]], suffix)
    return result


#These "asserts" using only for self-checking and not necessary for auto-testing
if __name__ == '__main__':
    assert friendly_number(102) == '102', '102'
    assert friendly_number(10240) == '10k', '10k'
    assert friendly_number(12341234, decimals=1) == '12.3M', '12.3M'
    assert friendly_number(12461, decimals=1) == '12.5k', '12.5k'
    assert friendly_number(1024000000, base=1024, suffix='iB') == '976MiB', '976MiB'
    assert friendly_number(255000000000, powers=['', 'k', 'M']) == "255000M", "недостаточно списка степеней."
    assert friendly_number(-150, base=100, powers=["","d","D"]) == "-1d", "-1d"
    assert friendly_number(10**24) == "1Y", "long "
    assert friendly_number(10**32) == "100000000Y", "big int"

"""Длинные числа можно переписать в более красивом виде. Так давайте напишем код для этого.

Вам нужно написать функцию для конвертации числа (аргумент number) используя следующие правила. 
Для начала, необходимо "обрезать" и округлить число до данной базы (аргумент base; по умолчанию 1000). 
Число должно стать коэффициентом с буквой (или буквами) определяющими степень базы. 
Коэффициент - это действительное число с определённым числом знаков после точки (аргумент decimals; по умолчанию 0). 
Вам дан список обозначений степеней (аргумент powers; по умолчанию ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y']). 
Если дан суффикс (аргумент suffix; по умолчанию ‘’) , то необходимо добавить его в конец результата. 
Коофицент округляется в сторону нуля (5.6⇒5, -5.6⇒-5), если decimal == 0, 
в остальных случаях используйте стандартное математическое округление. 
Если данного списка степеней недостаточно, то используйте последний, а дальше, как обычное число. 
Если необходимое количество знаков после запятой (decimals) больше чем необходимо, то дополняйте нулями. 
И ноль всегда ноль без всяких степеней.

Давайте рассмотрим примеры. Это будет проще понять.

n=102
Результат: "102", база по умолчанию 1000 и 102 меньше данной базы.
n=10240
Результат: "10k", база по умолчанию 1000 и округляем вниз.
n=12341234, decimals=1
Результат: "12.3M", один знак после точки.
n=12000000, decimals=3
Результат: "12.000M", дополняем нулями.
n=12461, decimals=1
Результат: "12.5k", стандартное округление.
n=1024000000, base=1024, suffix='iB'
Результат: '976MiB', новая база и суффикс.
n=-150, base=100, powers=['', 'd', 'D']
Результат: '-1d', Отрицательное число и округление в сторону нуля.
n=-155, base=100, decimals=1, powers=['', 'd', 'D']
Результат: '-1.6d', отрицательное число и стандартное округление.
n=255000000000, powers=['', 'k', 'M']
Результат: '255000M', недостаточно списка степеней.
Входные данные: Преобразуемое число, как целое число (int). Ключевой аргумент "base", как целое число (int), по умолчанию 1000. Ключевой аргумент "decimals", как целое число (int), по умолчанию 0. Ключевой аргумент "powers", как список (list) строк (str), по умолчанию 1000. ['', 'k', 'M', 'G', 'T', 'P', 'E', 'Z', 'Y'].

Выходные данные: Преобразованое число, как строка (str).

Связь с реальной жизнью: В физике и ИТ мы используем множество больших чисел. И часто нам нужно сделать их проще и понятней. Например, когда мы говорим о гигабайтах, то нам не интересно, сколько там байт в хвосте.

Предусловия: 1 < base ≤ 1032
-1032 < number ≤ 1032
0 ≤ decimals ≤ 15
0 < len(powers) ≤ 32
"""